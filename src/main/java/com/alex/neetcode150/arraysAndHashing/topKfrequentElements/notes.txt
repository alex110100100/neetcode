===================
347 - Top K Frequent Elements
===================

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.

Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]


Example 2:

Input: nums = [1], k = 1
Output: [1]




===================
Solution
===================

First, we need to determine the frequency of each element. This part is simple enough,
you just need to create a hashmap to hold each number as a key, and its frequency as the value.
Just iterate over the int array once and add them to the hashmap.

This part will have:
    Time complexity:    O(n)
    Space complexity:   O(n)


Next, we need to find a way to sort the elements by frequency and then return the top k values from it.

There are several ways you could do this:

*** NB: to add to or poll from a priority queue, takes logn time ***


1 - ~~~~~ USING MAX HEAP ~~~~~
    - Create a priority queue that uses a MAX heap, by using:     (a, b) -> counts.get(b) - counts.get(a)
    - Add all the hashmap keys to the pq.
    - Poll the first k elements.

    TODO - add time/space complexity


2 - ~~~~~ USING MIN HEAP ~~~~~
    - Create a priority queue that uses a MIN heap, by using:     (a, b) -> counts.get(a) - counts.get(b)
    - Iterate through the hashmap keys, adding to pq. If pq gets larger than k, then poll (this will remove the smallest element).
      This way means you are dealing with a smaller heap than the first solution.
    - Poll the elements of pq into the result array.

    TODO - add time/space complexity


3 - ~~~~~ USING BUCKETS ~~~~~
    - Create an array of integer lists (these will be our "buckets").
      The reason is that several elements could have the same frequency. e.g. [1, 2, 2, 3, 3, 4, 4]

      The index of the array is going to represent the frequency of the number.
        e.g. a list of 2, 3, 4 at index 2 would mean that the numbers 2, 3 and 4 each appeared twice in the original array.

      NB: the size our buckets array will need be 1 larger than the size of the original array (Due to zero-indexing. The index 0 will never actually be used).

    - iterate backwards through the k number of buckets. Return their contained values.

    TODO - add time/space complexity
